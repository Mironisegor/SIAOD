#include "Header.h"
#include <iostream>
#include <fstream>
#include <windows.h>

using namespace std;

/**
 * @brief Проверяет входную строку на соответствие допустимому алфавиту.
 *
 * @param str Входная строка.
 * @param alf Допустимый алфавит.
 * @return true Если в строке есть символы, не входящие в алфавит.
 * @return false Если все символы строки принадлежат алфавиту.
 */
extern "C" __declspec(dllexport) bool checkup(string str, set<char>&alf) {
    for (char sym : str) {
        if (alf.count(sym)) {
            continue;
        }
        else {
            return true;
        }
    }
    return false;
}

/**
 * @brief Добавляет пробелы в начале и в конце строки, если их нет.
 *
 * @param str Ссылка на входную строку.
 * @return string Измененная строка.
 */
extern "C" __declspec(dllexport) string addsymbols(string & str) {
    if (str[0] != ' ') {
        str = ' ' + str;
    }
    if (str.back() != ' ') {
        str = str + ' ';
    }
    return str;
}

/**
 * @brief Инициализирует таблицу переходов для машины Тьюринга.
 *
 * @param table Ссылка на таблицу переходов.
 * @return true Если файл не удалось открыть.
 * @return false Если инициализация прошла успешно.
 */
extern "C" __declspec(dllexport) bool init(deque<Transition>&table) {
    vector<char> alfavit = { '0', '1', '2', '3', '4', '5', '6', '7', '#', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', ' ' };
    ifstream inputFile("ИЗ_КТбо1-6_Миронов_11.2.txt");
    if (!inputFile) {
        cerr << "Файл не удалось открыть!" << endl;
        cerr << "Проверьте имя и расширение файла, после запустите программу заново";
        return true;
    }
    else {
        vector<char> alfavit = { '0', '1', '2', '3', '4', '5', '6', '7', '#', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', ' ' };
        for (int i = 0; i < 30; i++) {
            int cntForAlfavit = 0, flagForSpace = 0, flagForBreak = 0;;
            string inputStr;
            Transition instance, temp;
            getline(inputFile,inputStr);
            int lenForInputStr = inputStr.length();
            for (int j = 0; j < lenForInputStr; j++) {
                if (inputStr[j] == 'N') {
                    cntForAlfavit++;
                    flagForSpace = 1;
                    continue;
                }
                else if (flagForSpace) {
                    flagForSpace = 0;
                    continue;
                }
                else if ((inputStr[j] == '<' or inputStr[j] == '>') and inputStr[j+2] != 'q') {
                    instance.nowCondition = 'q' + to_string(i);
                    instance.direction = inputStr[j];
                    instance.nowSym = alfavit[cntForAlfavit];
                    table.push_back(instance);
                    instance = temp;
                    cntForAlfavit++;
                    flagForSpace = 1;
                }
                else if (inputStr[j] != '<' and inputStr[j] != '>' and inputStr[j + 4] == 'q') {
                    instance.nowSym = alfavit[cntForAlfavit];
                    instance.toSym = inputStr[j];
                    instance.direction = inputStr[j + 2];
                    instance.nowCondition = 'q' + to_string(i);
                    if ((j+6) <= (lenForInputStr-1) and isdigit(inputStr[j + 6])) {
                        instance.toCondition = "q" + to_string(inputStr[j + 5] - '0') + to_string(inputStr[j + 6] - '0');
                        if ((j + 6) == lenForInputStr-1) {
                            flagForBreak = 1;
                        }
                    }
                    else {
                        instance.toCondition = "q" + to_string(inputStr[j + 5] - '0');
                        if ((j + 5) == lenForInputStr-1) {
                            flagForBreak = 1;
                        }
                    }
                    table.push_back(instance);
                    instance = temp;
                    cntForAlfavit++;
                    flagForSpace = 1;
                    if (flagForBreak) {
                        break;
                    }
                }
            }
        }
        return false;
    }
}

/**
 * @brief Выполняет алгоритм машины Тьюринга на входной строке.
 *
 * @param str Ссылка на входную строку.
 * @param table Ссылка на таблицу переходов.
 */
extern "C" __declspec(dllexport) void turing(string & str, deque<Transition>&table) {
    int cnt = 0;
    string nowCondition = "q1";
    cout << str[0];
    setColor(4);
    cout << str[1];
    setColor(7);
    for (auto it = str.begin() + 2; it != str.end(); it++) {
        cout << *it;
    }
    cout << ' ' << nowCondition << endl;
    int indexForNowSym = 1;
    while (nowCondition != "q0") {
        addsymbols(str);
        auto it = find_if(table.begin(), table.end(), [nowCondition, &str, indexForNowSym](const Transition& t) {
            return t.nowCondition == nowCondition && t.nowSym == str[indexForNowSym];
            });
        if ((*it).toCondition[0] == 'q') {
            str[indexForNowSym] = (*it).toSym;
            nowCondition = (*it).toCondition;
            if ((*it).direction == '>') {
                indexForNowSym++;
            }
            else {
                indexForNowSym--;
            }
        }
        else if (((*it).direction == '>' || (*it).direction == '<') && ((*it).toSym == 'N')) {
            if ((*it).direction == '>') {
                indexForNowSym++;
            }
            else {
                indexForNowSym--;
            }
        }
        if (indexForNowSym == 0) {
            setColor(4);
            cout << str[indexForNowSym];
            setColor(7);
            for (size_t i = 1; i < str.length(); i++) {
                cout << str[i];
            }
        }
        else {
            for (size_t i = 0; i < indexForNowSym; i++) {
                cout << str[i];
            }
            setColor(4);
            cout << str[indexForNowSym];
            setColor(7);
            for (size_t i = indexForNowSym + 1; i < str.length(); i++) {
                cout << str[i];
            }
        }
        cout << ' ' << nowCondition << endl;
        cnt++;
        if (cnt == 10000) {
            cout << "Превышено максимальное количество шагов машины Тьюринга (10000)" << endl;
            nowCondition = "q0";
        }
    }
    cout << "Машина Тьюринга закончила свое выполнение" << endl;
}

/**
 * @brief Устанавливает цвет текста в консоли.
 *
 * @param color Код цвета.
 */
extern "C" __declspec(dllexport) void setColor(int color) {
    HANDLE hConsole = GetStdHandle(STD_OUTPUT_HANDLE);
    SetConsoleTextAttribute(hConsole, color);
}
