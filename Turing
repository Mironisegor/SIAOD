#include <iostream>
#include <string>
#include <vector>
#include <map>
#include <set>
#include <fstream>
#include <windows.h>

using namespace std;

typedef struct Transition {
	string nowCondition = "N";
	char nowSym = 'N';
	char toSym = 'N';
	char direction = 'N';
	string toCondition = "N";
}Transition;

//Функция для проверки входной цепочки
bool checkup(string str, set <char>& alf);

//Функция для инициализации таблицы замен
bool init(vector <Transition> &table);

//Функция для добавления пробелов справа и слева
string addsymbols(string& str);

//Функция смены цвета в консоли для отображение головки
void setColor(int color) {
	SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), color);
}
//Функция, которая реализовывает работу машины Тьюринга
void turing(string& str, vector <Transition>& table);


int main() {
	setlocale(LC_ALL, "Russian");
	int flag = 1;
	vector <Transition> table(522);
	//Инициализацию структуры данных
	if (init(table)) {
		cout << "Проверьте название файла и расширение, после запустите программу заново" << endl;
	}
	//Входной алфавит
	set <char> alf = {'0', '1', '2', '3', '4', '5', '6', '7'};
	do {
		string str;
		cout << "Введите входную цепочку: ";
			cin >> str;
		if (checkup(str, alf)) {
			cout << "Некоректный ввод! Входная цепочка должна состоять из цифр от 0 до 7 включительно" << endl;
				cout << "Введите 1, если хотите попробовать снова, иначе 0: ";
			cin >> flag;
			if (!flag) {
				break;
			}
		}
		else {
			//Добавление пробела справа и слева
			str = addsymbols(str);
			turing(str, table);
			cout << "Введите 1, если хотите ввести цепочку еще раз, иначе 0:";
			int flag1;
			cin >> flag1;
			if (!flag1) {
				break;
			}
		}
	} while (true);
	return 0;
}
bool checkup(string str, set <char>& alf) {
	for (char sym : str) {
		if (alf.count(sym)) {
			continue;
		}
		else {
			return true;
		}
	}
	return false;
}

string addsymbols(string& str) {
	if (str[0] != ' ') {
		str = ' ' + str;
	}
	if (str.back() != ' ') {
		str = str + ' ';
	}
	return str;
}

bool init(vector <Transition> &table) {
	vector <char> alfavit = {'0', '1', '2', '3', '4', '5', '6', '7', '#', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', ' '};
	ifstream inputFile("ИЗ_КТбо1-6_Миронов_11.2.txt");
	if (!inputFile) {
		cerr << "Невозможно открыть файл" << endl;
		return true;
	}
	else {
		int cntForQ = 0, space = 0, cntForVector = 0, cntForAlfavit = 0, flagForThree = 0, flagForQ = 0, cntForVectorMinusOne = 0;
		char ch;
		while (inputFile.get(ch)) {
			cntForVectorMinusOne = cntForVector;
			cntForVectorMinusOne--;
			if ((space == 0) and (cntForVectorMinusOne != -1) and (table[cntForVector].toCondition).length() == 2 and (ch < 48 or ch > 57)) {
				flagForQ = 0;
				flagForThree = 0;
				space = 0;
				cntForVector++;
				cntForAlfavit++;
			}
			else if (space and (ch < 48 or ch >578)) {
				space = 0;
				continue;
			}
			else {
				if (cntForVector != 0 and cntForVector % 18 == 0 and flagForThree == 0) {
					cntForQ++;
					cntForAlfavit = 0;
				}
				if (ch == 'N') {
					table[cntForVector].nowSym = alfavit[cntForAlfavit];
					table[cntForVector].nowCondition = "q" + to_string(cntForQ);
					cntForAlfavit++;
//					if (cntForAlfavit == 18) {
//						cntForAlfavit = 0;
//					}
					space = 1;
					cntForVector++;
				}
				else {
					if (ch >= 48 and ch <= 57 and flagForQ) {
						table[cntForVector].toCondition += ch;
						if ((table[cntForVector].toCondition).length() == 3) {
							flagForQ = 0;
							flagForThree = 0;
							cntForVector++;
							cntForAlfavit++;
							space = 1;
						}
					}
					else if (ch != '<' and ch != '>' and ch != 'q') {
						flagForThree = 1;
						table[cntForVector].toSym = ch;
						table[cntForVector].nowCondition = "q" + to_string(cntForQ);
						table[cntForVector].nowSym = alfavit[cntForAlfavit];
						space = 1;
					}
					else if (ch == '<' or ch == '>') {
						table[cntForVector].direction = ch;
						table[cntForVector].nowCondition = "q" + to_string(cntForQ);
						table[cntForVector].nowSym = alfavit[cntForAlfavit];
						space = 1;
						if (!flagForThree) {
							cntForAlfavit++;
							cntForVector++;
						}
					}
					else if (ch == 'q') {
						flagForQ = 1;
						table[cntForVector].toCondition = "q";
					}
				}
			}
		}
		return false;
	}
}

void turing(string& str, vector <Transition>& table) {
	string nowCondition = "q1";
	cout << str[0];
	setColor(4);
	cout << str[1];
	setColor(7);
	for (auto it = str.begin() + 2; it != str.end(); it++) {
		cout << *it;
	}
	cout << ' ' << nowCondition << endl;
	int indexForNowSym = 1;
	while (nowCondition != "q0") {
		addsymbols(str);
		auto it = find_if(table.begin(), table.end(), [nowCondition, &str, indexForNowSym](const Transition& t) {
			return t.nowCondition == nowCondition && t.nowSym == str[indexForNowSym];
			});
		if ((*it).toCondition[0] == 'q') {
			str[indexForNowSym] = (*it).toSym;
			nowCondition = (*it).toCondition;
			if ((*it).direction == '>') {
				indexForNowSym++;
			}
			else {
				indexForNowSym--;
			}
		}
		else if (((*it).direction == '>' or (*it).direction == '<') and ((*it).toSym == 'N')) {
			if ((*it).direction == '>') {
				indexForNowSym++;
			}
			else {
				indexForNowSym--;
			}
		}
		if (indexForNowSym == 0) {
			setColor(4);
			cout << str[indexForNowSym];
			setColor(7);
			for (int i = 1; i < str.length(); i++) {
				cout << str[i];
			}
		}
		else {
			for (int i = 0; i <indexForNowSym; i++) {
				cout << str[i];
			}
			setColor(4);
			cout << str[indexForNowSym];
			setColor(7);
			for (int i = indexForNowSym + 1; i < str.length(); i++) {
				cout << str[i];
			}
		}
		cout << ' ' << nowCondition << endl;
	}
}
